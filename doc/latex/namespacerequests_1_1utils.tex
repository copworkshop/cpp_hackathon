\hypertarget{namespacerequests_1_1utils}{}\doxysection{requests.\+utils Namespace Reference}
\label{namespacerequests_1_1utils}\index{requests.utils@{requests.utils}}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespacerequests_1_1utils_a07743c712848649787ce7bdac7a8601c}\label{namespacerequests_1_1utils_a07743c712848649787ce7bdac7a8601c}} 
def {\bfseries proxy\+\_\+bypass\+\_\+registry} (host)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a94605905bfa76b18c80b7792383df4b0}{proxy\+\_\+bypass}} (host)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a86aca220e9ffc3a0f5898b092d9e5eab}{dict\+\_\+to\+\_\+sequence}} (d)
\item 
\mbox{\Hypertarget{namespacerequests_1_1utils_a9ff2a13bb930c92c0da2a7630d62210b}\label{namespacerequests_1_1utils_a9ff2a13bb930c92c0da2a7630d62210b}} 
def {\bfseries super\+\_\+len} (o)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a4fda1fb3d07ed5063aa625ad61a72d87}{get\+\_\+netrc\+\_\+auth}} (url, raise\+\_\+errors=False)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a01dedd4e73dff4a1a07b4a47b68a97cd}{guess\+\_\+filename}} (obj)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_aa22bd813bbe89ef5698771b67345e052}{extract\+\_\+zipped\+\_\+paths}} (path)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_adff4a2b25cd7b42fb471f68a62631c93}{atomic\+\_\+open}} (filename)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a6342ae8a264363c0c509d73bb6248c0e}{from\+\_\+key\+\_\+val\+\_\+list}} (value)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a5e30cf6932c7530ebe17bf112d38abe9}{to\+\_\+key\+\_\+val\+\_\+list}} (value)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a8331f1a14b72efb735a78d39628c8b9b}{parse\+\_\+list\+\_\+header}} (value)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_aefdd9374efce4b3db9d039fc4e546fba}{parse\+\_\+dict\+\_\+header}} (value)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a04ea2ade3d27805232d09d1ac75b6903}{unquote\+\_\+header\+\_\+value}} (value, is\+\_\+filename=False)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a34ee29dbf43f884e11ca0fae15b0af85}{dict\+\_\+from\+\_\+cookiejar}} (cj)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_af65cf2b6740bee1ec36a2f5abdebf42a}{add\+\_\+dict\+\_\+to\+\_\+cookiejar}} (cj, cookie\+\_\+dict)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a5b54d750d98b3dadb28bb5eadb0c5b1e}{get\+\_\+encodings\+\_\+from\+\_\+content}} (content)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a755f8b393d139959fd223f67d12fe124}{get\+\_\+encoding\+\_\+from\+\_\+headers}} (headers)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_afa9ba8080660264e8c2dabbbb2ae8f22}{stream\+\_\+decode\+\_\+response\+\_\+unicode}} (iterator, r)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_ac66eacf6d8fa766c8a03444b44e6fb87}{iter\+\_\+slices}} (string, slice\+\_\+length)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a29e5d971d5ff3dd48f9e37dd571734d8}{get\+\_\+unicode\+\_\+from\+\_\+response}} (r)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a156e75ab96d697ea06ad4d2c2be9bc8e}{unquote\+\_\+unreserved}} (uri)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a5828b47667ffea42140ddee6f9286f06}{requote\+\_\+uri}} (uri)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a08f748a90a6b2571358b55c02400860e}{address\+\_\+in\+\_\+network}} (ip, net)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a7fff37faaeb4182d9d0a534e40cdc3be}{dotted\+\_\+netmask}} (mask)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_af3f15eb40c8a7992b19ec9830aeae389}{is\+\_\+ipv4\+\_\+address}} (string\+\_\+ip)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_abb556caf3042310a226b36c7ab6f8397}{is\+\_\+valid\+\_\+cidr}} (string\+\_\+network)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_afd9c4481e7b7ae3314cf702415fa6a4e}{set\+\_\+environ}} (env\+\_\+name, value)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a6cee944e44634f2425645832b105d559}{should\+\_\+bypass\+\_\+proxies}} (url, no\+\_\+proxy)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a3f3abd1a8d16c0a00c513ccdc3b75021}{get\+\_\+environ\+\_\+proxies}} (url, no\+\_\+proxy=None)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_ab178d5bf180f4ad51228e007d0333b22}{select\+\_\+proxy}} (url, proxies)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_aaaf4248b63fcc5e467c20e8ff069c774}{resolve\+\_\+proxies}} (request, proxies, trust\+\_\+env=True)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_ab4b6c96c7efcc8dec359408c8fc878ef}{default\+\_\+user\+\_\+agent}} (name=\char`\"{}python-\/requests\char`\"{})
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a263a216da0ad3e215df89cc292732d3c}{default\+\_\+headers}} ()
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_ae2a5368600f7cd79a768491f51d1c561}{parse\+\_\+header\+\_\+links}} (value)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_aaf52fc6fc221b334e9ea60884d9538a9}{guess\+\_\+json\+\_\+utf}} (data)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a134a61c931c4251a8dc70800ea19631a}{prepend\+\_\+scheme\+\_\+if\+\_\+needed}} (url, new\+\_\+scheme)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_ab3eaeb6ae7afae8a4e7bde47ad718ecc}{get\+\_\+auth\+\_\+from\+\_\+url}} (url)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a992d145060e8ffe37ff1669337cf1beb}{check\+\_\+header\+\_\+validity}} (header)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_a408f964507a9abdbd3557cf63ba91ce0}{urldefragauth}} (url)
\item 
def \mbox{\hyperlink{namespacerequests_1_1utils_ae3432beb83577b9d7442e164e2a31ce4}{rewind\+\_\+body}} (prepared\+\_\+request)
\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespacerequests_1_1utils_afafcfa0ad65e494e3dde57f669c0782e}\label{namespacerequests_1_1utils_afafcfa0ad65e494e3dde57f669c0782e}} 
{\bfseries NETRC\+\_\+\+FILES}
\item 
\mbox{\Hypertarget{namespacerequests_1_1utils_a34718944359129147da929ba2019100f}\label{namespacerequests_1_1utils_a34718944359129147da929ba2019100f}} 
{\bfseries DEFAULT\+\_\+\+CA\+\_\+\+BUNDLE\+\_\+\+PATH}
\item 
\mbox{\Hypertarget{namespacerequests_1_1utils_a5cfb59028a38d8e47f860b686d87ea77}\label{namespacerequests_1_1utils_a5cfb59028a38d8e47f860b686d87ea77}} 
{\bfseries DEFAULT\+\_\+\+PORTS}
\item 
\mbox{\Hypertarget{namespacerequests_1_1utils_a4f4c240ce68dbdc18b9a0d83028b0404}\label{namespacerequests_1_1utils_a4f4c240ce68dbdc18b9a0d83028b0404}} 
{\bfseries DEFAULT\+\_\+\+ACCEPT\+\_\+\+ENCODING}
\item 
\mbox{\Hypertarget{namespacerequests_1_1utils_a06db2df65ac89013c3f98efa6d00bd1a}\label{namespacerequests_1_1utils_a06db2df65ac89013c3f98efa6d00bd1a}} 
{\bfseries UNRESERVED\+\_\+\+SET}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}requests.utils
~~~~~~~~~~~~~~

This module provides utility functions that are used within Requests
that are also useful for external consumption.
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespacerequests_1_1utils_af65cf2b6740bee1ec36a2f5abdebf42a}\label{namespacerequests_1_1utils_af65cf2b6740bee1ec36a2f5abdebf42a}} 
\index{requests.utils@{requests.utils}!add\_dict\_to\_cookiejar@{add\_dict\_to\_cookiejar}}
\index{add\_dict\_to\_cookiejar@{add\_dict\_to\_cookiejar}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{add\_dict\_to\_cookiejar()}{add\_dict\_to\_cookiejar()}}
{\footnotesize\ttfamily def requests.\+utils.\+add\+\_\+dict\+\_\+to\+\_\+cookiejar (\begin{DoxyParamCaption}\item[{}]{cj,  }\item[{}]{cookie\+\_\+dict }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a CookieJar from a key/value dictionary.

:param cj: CookieJar to insert cookies into.
:param cookie_dict: Dict of key/values to insert into CookieJar.
:rtype: CookieJar
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a08f748a90a6b2571358b55c02400860e}\label{namespacerequests_1_1utils_a08f748a90a6b2571358b55c02400860e}} 
\index{requests.utils@{requests.utils}!address\_in\_network@{address\_in\_network}}
\index{address\_in\_network@{address\_in\_network}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{address\_in\_network()}{address\_in\_network()}}
{\footnotesize\ttfamily def requests.\+utils.\+address\+\_\+in\+\_\+network (\begin{DoxyParamCaption}\item[{}]{ip,  }\item[{}]{net }\end{DoxyParamCaption})}

\begin{DoxyVerb}This function allows you to check if an IP belongs to a network subnet

Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24
         returns False if ip = 192.168.1.1 and net = 192.168.100.0/24

:rtype: bool
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_adff4a2b25cd7b42fb471f68a62631c93}\label{namespacerequests_1_1utils_adff4a2b25cd7b42fb471f68a62631c93}} 
\index{requests.utils@{requests.utils}!atomic\_open@{atomic\_open}}
\index{atomic\_open@{atomic\_open}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{atomic\_open()}{atomic\_open()}}
{\footnotesize\ttfamily def requests.\+utils.\+atomic\+\_\+open (\begin{DoxyParamCaption}\item[{}]{filename }\end{DoxyParamCaption})}

\begin{DoxyVerb}Write a file to the disk in an atomic fashion\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a992d145060e8ffe37ff1669337cf1beb}\label{namespacerequests_1_1utils_a992d145060e8ffe37ff1669337cf1beb}} 
\index{requests.utils@{requests.utils}!check\_header\_validity@{check\_header\_validity}}
\index{check\_header\_validity@{check\_header\_validity}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{check\_header\_validity()}{check\_header\_validity()}}
{\footnotesize\ttfamily def requests.\+utils.\+check\+\_\+header\+\_\+validity (\begin{DoxyParamCaption}\item[{}]{header }\end{DoxyParamCaption})}

\begin{DoxyVerb}Verifies that header parts don't contain leading whitespace
reserved characters, or return characters.

:param header: tuple, in the format (name, value).
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a263a216da0ad3e215df89cc292732d3c}\label{namespacerequests_1_1utils_a263a216da0ad3e215df89cc292732d3c}} 
\index{requests.utils@{requests.utils}!default\_headers@{default\_headers}}
\index{default\_headers@{default\_headers}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{default\_headers()}{default\_headers()}}
{\footnotesize\ttfamily def requests.\+utils.\+default\+\_\+headers (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyVerb}:rtype: requests.structures.CaseInsensitiveDict
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_ab4b6c96c7efcc8dec359408c8fc878ef}\label{namespacerequests_1_1utils_ab4b6c96c7efcc8dec359408c8fc878ef}} 
\index{requests.utils@{requests.utils}!default\_user\_agent@{default\_user\_agent}}
\index{default\_user\_agent@{default\_user\_agent}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{default\_user\_agent()}{default\_user\_agent()}}
{\footnotesize\ttfamily def requests.\+utils.\+default\+\_\+user\+\_\+agent (\begin{DoxyParamCaption}\item[{}]{name = {\ttfamily \char`\"{}python-\/requests\char`\"{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a string representing the default user agent.

:rtype: str
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a34ee29dbf43f884e11ca0fae15b0af85}\label{namespacerequests_1_1utils_a34ee29dbf43f884e11ca0fae15b0af85}} 
\index{requests.utils@{requests.utils}!dict\_from\_cookiejar@{dict\_from\_cookiejar}}
\index{dict\_from\_cookiejar@{dict\_from\_cookiejar}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{dict\_from\_cookiejar()}{dict\_from\_cookiejar()}}
{\footnotesize\ttfamily def requests.\+utils.\+dict\+\_\+from\+\_\+cookiejar (\begin{DoxyParamCaption}\item[{}]{cj }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a key/value dictionary from a CookieJar.

:param cj: CookieJar object to extract cookies from.
:rtype: dict
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a86aca220e9ffc3a0f5898b092d9e5eab}\label{namespacerequests_1_1utils_a86aca220e9ffc3a0f5898b092d9e5eab}} 
\index{requests.utils@{requests.utils}!dict\_to\_sequence@{dict\_to\_sequence}}
\index{dict\_to\_sequence@{dict\_to\_sequence}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{dict\_to\_sequence()}{dict\_to\_sequence()}}
{\footnotesize\ttfamily def requests.\+utils.\+dict\+\_\+to\+\_\+sequence (\begin{DoxyParamCaption}\item[{}]{d }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns an internal sequence dictionary update.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a7fff37faaeb4182d9d0a534e40cdc3be}\label{namespacerequests_1_1utils_a7fff37faaeb4182d9d0a534e40cdc3be}} 
\index{requests.utils@{requests.utils}!dotted\_netmask@{dotted\_netmask}}
\index{dotted\_netmask@{dotted\_netmask}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{dotted\_netmask()}{dotted\_netmask()}}
{\footnotesize\ttfamily def requests.\+utils.\+dotted\+\_\+netmask (\begin{DoxyParamCaption}\item[{}]{mask }\end{DoxyParamCaption})}

\begin{DoxyVerb}Converts mask from /xx format to xxx.xxx.xxx.xxx

Example: if mask is 24 function returns 255.255.255.0

:rtype: str
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_aa22bd813bbe89ef5698771b67345e052}\label{namespacerequests_1_1utils_aa22bd813bbe89ef5698771b67345e052}} 
\index{requests.utils@{requests.utils}!extract\_zipped\_paths@{extract\_zipped\_paths}}
\index{extract\_zipped\_paths@{extract\_zipped\_paths}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{extract\_zipped\_paths()}{extract\_zipped\_paths()}}
{\footnotesize\ttfamily def requests.\+utils.\+extract\+\_\+zipped\+\_\+paths (\begin{DoxyParamCaption}\item[{}]{path }\end{DoxyParamCaption})}

\begin{DoxyVerb}Replace nonexistent paths that look like they refer to a member of a zip
archive with the location of an extracted copy of the target, or else
just return the provided path unchanged.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a6342ae8a264363c0c509d73bb6248c0e}\label{namespacerequests_1_1utils_a6342ae8a264363c0c509d73bb6248c0e}} 
\index{requests.utils@{requests.utils}!from\_key\_val\_list@{from\_key\_val\_list}}
\index{from\_key\_val\_list@{from\_key\_val\_list}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{from\_key\_val\_list()}{from\_key\_val\_list()}}
{\footnotesize\ttfamily def requests.\+utils.\+from\+\_\+key\+\_\+val\+\_\+list (\begin{DoxyParamCaption}\item[{}]{value }\end{DoxyParamCaption})}

\begin{DoxyVerb}Take an object and test to see if it can be represented as a
dictionary. Unless it can not be represented as such, return an
OrderedDict, e.g.,

::

    >>> from_key_val_list([('key', 'val')])
    OrderedDict([('key', 'val')])
    >>> from_key_val_list('string')
    Traceback (most recent call last):
    ...
    ValueError: cannot encode objects that are not 2-tuples
    >>> from_key_val_list({'key': 'val'})
    OrderedDict([('key', 'val')])

:rtype: OrderedDict
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_ab3eaeb6ae7afae8a4e7bde47ad718ecc}\label{namespacerequests_1_1utils_ab3eaeb6ae7afae8a4e7bde47ad718ecc}} 
\index{requests.utils@{requests.utils}!get\_auth\_from\_url@{get\_auth\_from\_url}}
\index{get\_auth\_from\_url@{get\_auth\_from\_url}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{get\_auth\_from\_url()}{get\_auth\_from\_url()}}
{\footnotesize\ttfamily def requests.\+utils.\+get\+\_\+auth\+\_\+from\+\_\+url (\begin{DoxyParamCaption}\item[{}]{url }\end{DoxyParamCaption})}

\begin{DoxyVerb}Given a url with authentication components, extract them into a tuple of
username,password.

:rtype: (str,str)
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a755f8b393d139959fd223f67d12fe124}\label{namespacerequests_1_1utils_a755f8b393d139959fd223f67d12fe124}} 
\index{requests.utils@{requests.utils}!get\_encoding\_from\_headers@{get\_encoding\_from\_headers}}
\index{get\_encoding\_from\_headers@{get\_encoding\_from\_headers}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{get\_encoding\_from\_headers()}{get\_encoding\_from\_headers()}}
{\footnotesize\ttfamily def requests.\+utils.\+get\+\_\+encoding\+\_\+from\+\_\+headers (\begin{DoxyParamCaption}\item[{}]{headers }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns encodings from given HTTP Header Dict.

:param headers: dictionary to extract encoding from.
:rtype: str
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a5b54d750d98b3dadb28bb5eadb0c5b1e}\label{namespacerequests_1_1utils_a5b54d750d98b3dadb28bb5eadb0c5b1e}} 
\index{requests.utils@{requests.utils}!get\_encodings\_from\_content@{get\_encodings\_from\_content}}
\index{get\_encodings\_from\_content@{get\_encodings\_from\_content}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{get\_encodings\_from\_content()}{get\_encodings\_from\_content()}}
{\footnotesize\ttfamily def requests.\+utils.\+get\+\_\+encodings\+\_\+from\+\_\+content (\begin{DoxyParamCaption}\item[{}]{content }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns encodings from given content string.

:param content: bytestring to extract encodings from.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a3f3abd1a8d16c0a00c513ccdc3b75021}\label{namespacerequests_1_1utils_a3f3abd1a8d16c0a00c513ccdc3b75021}} 
\index{requests.utils@{requests.utils}!get\_environ\_proxies@{get\_environ\_proxies}}
\index{get\_environ\_proxies@{get\_environ\_proxies}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{get\_environ\_proxies()}{get\_environ\_proxies()}}
{\footnotesize\ttfamily def requests.\+utils.\+get\+\_\+environ\+\_\+proxies (\begin{DoxyParamCaption}\item[{}]{url,  }\item[{}]{no\+\_\+proxy = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a dict of environment proxies.

:rtype: dict
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a4fda1fb3d07ed5063aa625ad61a72d87}\label{namespacerequests_1_1utils_a4fda1fb3d07ed5063aa625ad61a72d87}} 
\index{requests.utils@{requests.utils}!get\_netrc\_auth@{get\_netrc\_auth}}
\index{get\_netrc\_auth@{get\_netrc\_auth}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{get\_netrc\_auth()}{get\_netrc\_auth()}}
{\footnotesize\ttfamily def requests.\+utils.\+get\+\_\+netrc\+\_\+auth (\begin{DoxyParamCaption}\item[{}]{url,  }\item[{}]{raise\+\_\+errors = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the Requests tuple auth for a given url from netrc.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a29e5d971d5ff3dd48f9e37dd571734d8}\label{namespacerequests_1_1utils_a29e5d971d5ff3dd48f9e37dd571734d8}} 
\index{requests.utils@{requests.utils}!get\_unicode\_from\_response@{get\_unicode\_from\_response}}
\index{get\_unicode\_from\_response@{get\_unicode\_from\_response}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{get\_unicode\_from\_response()}{get\_unicode\_from\_response()}}
{\footnotesize\ttfamily def requests.\+utils.\+get\+\_\+unicode\+\_\+from\+\_\+response (\begin{DoxyParamCaption}\item[{}]{r }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the requested content back in unicode.

:param r: Response object to get unicode content from.

Tried:

1. charset from content-type
2. fall back and replace all unicode characters

:rtype: str
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a01dedd4e73dff4a1a07b4a47b68a97cd}\label{namespacerequests_1_1utils_a01dedd4e73dff4a1a07b4a47b68a97cd}} 
\index{requests.utils@{requests.utils}!guess\_filename@{guess\_filename}}
\index{guess\_filename@{guess\_filename}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{guess\_filename()}{guess\_filename()}}
{\footnotesize\ttfamily def requests.\+utils.\+guess\+\_\+filename (\begin{DoxyParamCaption}\item[{}]{obj }\end{DoxyParamCaption})}

\begin{DoxyVerb}Tries to guess the filename of the given object.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_aaf52fc6fc221b334e9ea60884d9538a9}\label{namespacerequests_1_1utils_aaf52fc6fc221b334e9ea60884d9538a9}} 
\index{requests.utils@{requests.utils}!guess\_json\_utf@{guess\_json\_utf}}
\index{guess\_json\_utf@{guess\_json\_utf}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{guess\_json\_utf()}{guess\_json\_utf()}}
{\footnotesize\ttfamily def requests.\+utils.\+guess\+\_\+json\+\_\+utf (\begin{DoxyParamCaption}\item[{}]{data }\end{DoxyParamCaption})}

\begin{DoxyVerb}:rtype: str
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_af3f15eb40c8a7992b19ec9830aeae389}\label{namespacerequests_1_1utils_af3f15eb40c8a7992b19ec9830aeae389}} 
\index{requests.utils@{requests.utils}!is\_ipv4\_address@{is\_ipv4\_address}}
\index{is\_ipv4\_address@{is\_ipv4\_address}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{is\_ipv4\_address()}{is\_ipv4\_address()}}
{\footnotesize\ttfamily def requests.\+utils.\+is\+\_\+ipv4\+\_\+address (\begin{DoxyParamCaption}\item[{}]{string\+\_\+ip }\end{DoxyParamCaption})}

\begin{DoxyVerb}:rtype: bool
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_abb556caf3042310a226b36c7ab6f8397}\label{namespacerequests_1_1utils_abb556caf3042310a226b36c7ab6f8397}} 
\index{requests.utils@{requests.utils}!is\_valid\_cidr@{is\_valid\_cidr}}
\index{is\_valid\_cidr@{is\_valid\_cidr}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{is\_valid\_cidr()}{is\_valid\_cidr()}}
{\footnotesize\ttfamily def requests.\+utils.\+is\+\_\+valid\+\_\+cidr (\begin{DoxyParamCaption}\item[{}]{string\+\_\+network }\end{DoxyParamCaption})}

\begin{DoxyVerb}Very simple check of the cidr format in no_proxy variable.

:rtype: bool
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_ac66eacf6d8fa766c8a03444b44e6fb87}\label{namespacerequests_1_1utils_ac66eacf6d8fa766c8a03444b44e6fb87}} 
\index{requests.utils@{requests.utils}!iter\_slices@{iter\_slices}}
\index{iter\_slices@{iter\_slices}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{iter\_slices()}{iter\_slices()}}
{\footnotesize\ttfamily def requests.\+utils.\+iter\+\_\+slices (\begin{DoxyParamCaption}\item[{}]{string,  }\item[{}]{slice\+\_\+length }\end{DoxyParamCaption})}

\begin{DoxyVerb}Iterate over slices of a string.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_aefdd9374efce4b3db9d039fc4e546fba}\label{namespacerequests_1_1utils_aefdd9374efce4b3db9d039fc4e546fba}} 
\index{requests.utils@{requests.utils}!parse\_dict\_header@{parse\_dict\_header}}
\index{parse\_dict\_header@{parse\_dict\_header}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{parse\_dict\_header()}{parse\_dict\_header()}}
{\footnotesize\ttfamily def requests.\+utils.\+parse\+\_\+dict\+\_\+header (\begin{DoxyParamCaption}\item[{}]{value }\end{DoxyParamCaption})}

\begin{DoxyVerb}Parse lists of key, value pairs as described by RFC 2068 Section 2 and
convert them into a python dict:

>>> d = parse_dict_header('foo="is a fish", bar="as well"')
>>> type(d) is dict
True
>>> sorted(d.items())
[('bar', 'as well'), ('foo', 'is a fish')]

If there is no value for a key it will be `None`:

>>> parse_dict_header('key_without_value')
{'key_without_value': None}

To create a header from the :class:`dict` again, use the
:func:`dump_header` function.

:param value: a string with a dict header.
:return: :class:`dict`
:rtype: dict
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_ae2a5368600f7cd79a768491f51d1c561}\label{namespacerequests_1_1utils_ae2a5368600f7cd79a768491f51d1c561}} 
\index{requests.utils@{requests.utils}!parse\_header\_links@{parse\_header\_links}}
\index{parse\_header\_links@{parse\_header\_links}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{parse\_header\_links()}{parse\_header\_links()}}
{\footnotesize\ttfamily def requests.\+utils.\+parse\+\_\+header\+\_\+links (\begin{DoxyParamCaption}\item[{}]{value }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a list of parsed link headers proxies.

i.e. Link: <http:/.../front.jpeg>; rel=front; type="image/jpeg",<http://.../back.jpeg>; rel=back;type="image/jpeg"

:rtype: list
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a8331f1a14b72efb735a78d39628c8b9b}\label{namespacerequests_1_1utils_a8331f1a14b72efb735a78d39628c8b9b}} 
\index{requests.utils@{requests.utils}!parse\_list\_header@{parse\_list\_header}}
\index{parse\_list\_header@{parse\_list\_header}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{parse\_list\_header()}{parse\_list\_header()}}
{\footnotesize\ttfamily def requests.\+utils.\+parse\+\_\+list\+\_\+header (\begin{DoxyParamCaption}\item[{}]{value }\end{DoxyParamCaption})}

\begin{DoxyVerb}Parse lists as described by RFC 2068 Section 2.

In particular, parse comma-separated lists where the elements of
the list may include quoted-strings.  A quoted-string could
contain a comma.  A non-quoted string could have quotes in the
middle.  Quotes are removed automatically after parsing.

It basically works like :func:`parse_set_header` just that items
may appear multiple times and case sensitivity is preserved.

The return value is a standard :class:`list`:

>>> parse_list_header('token, "quoted value"')
['token', 'quoted value']

To create a header from the :class:`list` again, use the
:func:`dump_header` function.

:param value: a string with a list header.
:return: :class:`list`
:rtype: list
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a134a61c931c4251a8dc70800ea19631a}\label{namespacerequests_1_1utils_a134a61c931c4251a8dc70800ea19631a}} 
\index{requests.utils@{requests.utils}!prepend\_scheme\_if\_needed@{prepend\_scheme\_if\_needed}}
\index{prepend\_scheme\_if\_needed@{prepend\_scheme\_if\_needed}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{prepend\_scheme\_if\_needed()}{prepend\_scheme\_if\_needed()}}
{\footnotesize\ttfamily def requests.\+utils.\+prepend\+\_\+scheme\+\_\+if\+\_\+needed (\begin{DoxyParamCaption}\item[{}]{url,  }\item[{}]{new\+\_\+scheme }\end{DoxyParamCaption})}

\begin{DoxyVerb}Given a URL that may or may not have a scheme, prepend the given scheme.
Does not replace a present scheme with the one provided as an argument.

:rtype: str
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a94605905bfa76b18c80b7792383df4b0}\label{namespacerequests_1_1utils_a94605905bfa76b18c80b7792383df4b0}} 
\index{requests.utils@{requests.utils}!proxy\_bypass@{proxy\_bypass}}
\index{proxy\_bypass@{proxy\_bypass}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{proxy\_bypass()}{proxy\_bypass()}}
{\footnotesize\ttfamily def requests.\+utils.\+proxy\+\_\+bypass (\begin{DoxyParamCaption}\item[{}]{host }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return True, if the host should be bypassed.

Checks proxy settings gathered from the environment, if specified,
or the registry.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a5828b47667ffea42140ddee6f9286f06}\label{namespacerequests_1_1utils_a5828b47667ffea42140ddee6f9286f06}} 
\index{requests.utils@{requests.utils}!requote\_uri@{requote\_uri}}
\index{requote\_uri@{requote\_uri}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{requote\_uri()}{requote\_uri()}}
{\footnotesize\ttfamily def requests.\+utils.\+requote\+\_\+uri (\begin{DoxyParamCaption}\item[{}]{uri }\end{DoxyParamCaption})}

\begin{DoxyVerb}Re-quote the given URI.

This function passes the given URI through an unquote/quote cycle to
ensure that it is fully and consistently quoted.

:rtype: str
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_aaaf4248b63fcc5e467c20e8ff069c774}\label{namespacerequests_1_1utils_aaaf4248b63fcc5e467c20e8ff069c774}} 
\index{requests.utils@{requests.utils}!resolve\_proxies@{resolve\_proxies}}
\index{resolve\_proxies@{resolve\_proxies}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{resolve\_proxies()}{resolve\_proxies()}}
{\footnotesize\ttfamily def requests.\+utils.\+resolve\+\_\+proxies (\begin{DoxyParamCaption}\item[{}]{request,  }\item[{}]{proxies,  }\item[{}]{trust\+\_\+env = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}This method takes proxy information from a request and configuration
input to resolve a mapping of target proxies. This will consider settings
such as NO_PROXY to strip proxy configurations.

:param request: Request or PreparedRequest
:param proxies: A dictionary of schemes or schemes and hosts to proxy URLs
:param trust_env: Boolean declaring whether to trust environment configs

:rtype: dict
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_ae3432beb83577b9d7442e164e2a31ce4}\label{namespacerequests_1_1utils_ae3432beb83577b9d7442e164e2a31ce4}} 
\index{requests.utils@{requests.utils}!rewind\_body@{rewind\_body}}
\index{rewind\_body@{rewind\_body}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{rewind\_body()}{rewind\_body()}}
{\footnotesize\ttfamily def requests.\+utils.\+rewind\+\_\+body (\begin{DoxyParamCaption}\item[{}]{prepared\+\_\+request }\end{DoxyParamCaption})}

\begin{DoxyVerb}Move file pointer back to its recorded starting position
so it can be read again on redirect.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_ab178d5bf180f4ad51228e007d0333b22}\label{namespacerequests_1_1utils_ab178d5bf180f4ad51228e007d0333b22}} 
\index{requests.utils@{requests.utils}!select\_proxy@{select\_proxy}}
\index{select\_proxy@{select\_proxy}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{select\_proxy()}{select\_proxy()}}
{\footnotesize\ttfamily def requests.\+utils.\+select\+\_\+proxy (\begin{DoxyParamCaption}\item[{}]{url,  }\item[{}]{proxies }\end{DoxyParamCaption})}

\begin{DoxyVerb}Select a proxy for the url, if applicable.

:param url: The url being for the request
:param proxies: A dictionary of schemes or schemes and hosts to proxy URLs
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_afd9c4481e7b7ae3314cf702415fa6a4e}\label{namespacerequests_1_1utils_afd9c4481e7b7ae3314cf702415fa6a4e}} 
\index{requests.utils@{requests.utils}!set\_environ@{set\_environ}}
\index{set\_environ@{set\_environ}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{set\_environ()}{set\_environ()}}
{\footnotesize\ttfamily def requests.\+utils.\+set\+\_\+environ (\begin{DoxyParamCaption}\item[{}]{env\+\_\+name,  }\item[{}]{value }\end{DoxyParamCaption})}

\begin{DoxyVerb}Set the environment variable 'env_name' to 'value'

Save previous value, yield, and then restore the previous value stored in
the environment variable 'env_name'.

If 'value' is None, do nothing\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a6cee944e44634f2425645832b105d559}\label{namespacerequests_1_1utils_a6cee944e44634f2425645832b105d559}} 
\index{requests.utils@{requests.utils}!should\_bypass\_proxies@{should\_bypass\_proxies}}
\index{should\_bypass\_proxies@{should\_bypass\_proxies}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{should\_bypass\_proxies()}{should\_bypass\_proxies()}}
{\footnotesize\ttfamily def requests.\+utils.\+should\+\_\+bypass\+\_\+proxies (\begin{DoxyParamCaption}\item[{}]{url,  }\item[{}]{no\+\_\+proxy }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns whether we should bypass proxies or not.

:rtype: bool
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_afa9ba8080660264e8c2dabbbb2ae8f22}\label{namespacerequests_1_1utils_afa9ba8080660264e8c2dabbbb2ae8f22}} 
\index{requests.utils@{requests.utils}!stream\_decode\_response\_unicode@{stream\_decode\_response\_unicode}}
\index{stream\_decode\_response\_unicode@{stream\_decode\_response\_unicode}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{stream\_decode\_response\_unicode()}{stream\_decode\_response\_unicode()}}
{\footnotesize\ttfamily def requests.\+utils.\+stream\+\_\+decode\+\_\+response\+\_\+unicode (\begin{DoxyParamCaption}\item[{}]{iterator,  }\item[{}]{r }\end{DoxyParamCaption})}

\begin{DoxyVerb}Stream decodes an iterator.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a5e30cf6932c7530ebe17bf112d38abe9}\label{namespacerequests_1_1utils_a5e30cf6932c7530ebe17bf112d38abe9}} 
\index{requests.utils@{requests.utils}!to\_key\_val\_list@{to\_key\_val\_list}}
\index{to\_key\_val\_list@{to\_key\_val\_list}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{to\_key\_val\_list()}{to\_key\_val\_list()}}
{\footnotesize\ttfamily def requests.\+utils.\+to\+\_\+key\+\_\+val\+\_\+list (\begin{DoxyParamCaption}\item[{}]{value }\end{DoxyParamCaption})}

\begin{DoxyVerb}Take an object and test to see if it can be represented as a
dictionary. If it can be, return a list of tuples, e.g.,

::

    >>> to_key_val_list([('key', 'val')])
    [('key', 'val')]
    >>> to_key_val_list({'key': 'val'})
    [('key', 'val')]
    >>> to_key_val_list('string')
    Traceback (most recent call last):
    ...
    ValueError: cannot encode objects that are not 2-tuples

:rtype: list
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a04ea2ade3d27805232d09d1ac75b6903}\label{namespacerequests_1_1utils_a04ea2ade3d27805232d09d1ac75b6903}} 
\index{requests.utils@{requests.utils}!unquote\_header\_value@{unquote\_header\_value}}
\index{unquote\_header\_value@{unquote\_header\_value}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{unquote\_header\_value()}{unquote\_header\_value()}}
{\footnotesize\ttfamily def requests.\+utils.\+unquote\+\_\+header\+\_\+value (\begin{DoxyParamCaption}\item[{}]{value,  }\item[{}]{is\+\_\+filename = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Unquotes a header value.  (Reversal of :func:`quote_header_value`).
This does not use the real unquoting but what browsers are actually
using for quoting.

:param value: the header value to unquote.
:rtype: str
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a156e75ab96d697ea06ad4d2c2be9bc8e}\label{namespacerequests_1_1utils_a156e75ab96d697ea06ad4d2c2be9bc8e}} 
\index{requests.utils@{requests.utils}!unquote\_unreserved@{unquote\_unreserved}}
\index{unquote\_unreserved@{unquote\_unreserved}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{unquote\_unreserved()}{unquote\_unreserved()}}
{\footnotesize\ttfamily def requests.\+utils.\+unquote\+\_\+unreserved (\begin{DoxyParamCaption}\item[{}]{uri }\end{DoxyParamCaption})}

\begin{DoxyVerb}Un-escape any percent-escape sequences in a URI that are unreserved
characters. This leaves all reserved, illegal and non-ASCII bytes encoded.

:rtype: str
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacerequests_1_1utils_a408f964507a9abdbd3557cf63ba91ce0}\label{namespacerequests_1_1utils_a408f964507a9abdbd3557cf63ba91ce0}} 
\index{requests.utils@{requests.utils}!urldefragauth@{urldefragauth}}
\index{urldefragauth@{urldefragauth}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{urldefragauth()}{urldefragauth()}}
{\footnotesize\ttfamily def requests.\+utils.\+urldefragauth (\begin{DoxyParamCaption}\item[{}]{url }\end{DoxyParamCaption})}

\begin{DoxyVerb}Given a url remove the fragment and the authentication part.

:rtype: str
\end{DoxyVerb}
 