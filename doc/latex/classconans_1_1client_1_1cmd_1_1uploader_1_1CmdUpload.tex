\hypertarget{classconans_1_1client_1_1cmd_1_1uploader_1_1CmdUpload}{}\doxysection{conans.\+client.\+cmd.\+uploader.\+Cmd\+Upload Class Reference}
\label{classconans_1_1client_1_1cmd_1_1uploader_1_1CmdUpload}\index{conans.client.cmd.uploader.CmdUpload@{conans.client.cmd.uploader.CmdUpload}}


Inheritance diagram for conans.\+client.\+cmd.\+uploader.\+Cmd\+Upload\+:
% FIG 0


Collaboration diagram for conans.\+client.\+cmd.\+uploader.\+Cmd\+Upload\+:
% FIG 1
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classconans_1_1client_1_1cmd_1_1uploader_1_1CmdUpload_a734f9e8951594fa9e2cb4638c8700789}\label{classconans_1_1client_1_1cmd_1_1uploader_1_1CmdUpload_a734f9e8951594fa9e2cb4638c8700789}} 
def {\bfseries \+\_\+\+\_\+init\+\_\+\+\_\+} (self, cache, user\+\_\+io, remote\+\_\+manager, loader, hook\+\_\+manager)
\item 
\mbox{\Hypertarget{classconans_1_1client_1_1cmd_1_1uploader_1_1CmdUpload_ad47297a0a8046c319a385a9173ed9c0d}\label{classconans_1_1client_1_1cmd_1_1uploader_1_1CmdUpload_ad47297a0a8046c319a385a9173ed9c0d}} 
def {\bfseries upload} (self, reference\+\_\+or\+\_\+pattern, remotes, upload\+\_\+recorder, package\+\_\+id=None, all\+\_\+packages=None, confirm=False, retry=None, retry\+\_\+wait=None, integrity\+\_\+check=False, policy=None, query=None, parallel\+\_\+upload=False)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb} This class is responsible for uploading packages to remotes. The flow is:
- Collect all the packages to be uploaded with the UploadCollecter
- Execute the upload. For every ref:
    - Upload the recipe of the ref: "_upload_recipe"
        - If not FORCE, check the date "_check_recipe_date", i.e. if there are
          changes, do not allow uploading if the remote date is newer than the
          local cache one
        - Retrieve the sources (exports_sources), if they are not cached, and
          uploading to a different remote. "retrieve_exports_sources"
        - Gather files and create 2 .tgz (exports, exports_sources) with
          "_compress_recipe_files"
        - Decide which files have to be uploaded and deleted from the server
          based on the different with the remote snapshot "_recipe_files_to_upload"
          This can raise if upload policy is not overwrite
        - Execute the real transfer "remote_manager.upload_recipe()"
    - For every package_id of every ref: "_upload_package"
        - Gather files and create package.tgz. "_compress_package_files"
        - (Optional) Do the integrity check of the package
        - Decide which files to upload and delete from server:
          "_package_files_to_upload". Can raise if policy is NOT overwrite
        - Do the actual upload

All the REVISIONS are local defined, not retrieved from servers

This requires calling to the remote API methods:
- get_recipe_sources() to get the export_sources if they are missing
- get_recipe_snapshot() to do the diff and know what files to upload
- get_package_snapshot() to do the diff and know what files to upload
- get_recipe_manifest() to check the date and raise if policy requires
- get_package_manifest() to raise if policy!=force and manifests change
\end{DoxyVerb}
 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
venv/lib/python3.\+10/site-\/packages/conans/client/cmd/uploader.\+py\end{DoxyCompactItemize}
