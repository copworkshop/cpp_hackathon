\hypertarget{classjinja2_1_1nodes_1_1InternalName}{}\doxysection{jinja2.\+nodes.\+Internal\+Name Class Reference}
\label{classjinja2_1_1nodes_1_1InternalName}\index{jinja2.nodes.InternalName@{jinja2.nodes.InternalName}}


Inheritance diagram for jinja2.\+nodes.\+Internal\+Name\+:
% FIG 0


Collaboration diagram for jinja2.\+nodes.\+Internal\+Name\+:
% FIG 1
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classjinja2_1_1nodes_1_1InternalName_a4a9d6c07a2443835ef7147185adb80c9}\label{classjinja2_1_1nodes_1_1InternalName_a4a9d6c07a2443835ef7147185adb80c9}} 
None {\bfseries \+\_\+\+\_\+init\+\_\+\+\_\+} (self)
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classjinja2_1_1nodes_1_1InternalName_a8ef35cfa181b08cd5be2b5e5cabc903b}\label{classjinja2_1_1nodes_1_1InternalName_a8ef35cfa181b08cd5be2b5e5cabc903b}} 
tuple {\bfseries fields} = (\char`\"{}name\char`\"{},)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}An internal name in the compiler.  You cannot create these nodes
yourself but the parser provides a
:meth:`~jinja2.parser.Parser.free_identifier` method that creates
a new identifier for you.  This identifier is not available from the
template and is not treated specially by the compiler.
\end{DoxyVerb}
 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
venv/lib/python3.\+10/site-\/packages/jinja2/nodes.\+py\end{DoxyCompactItemize}
